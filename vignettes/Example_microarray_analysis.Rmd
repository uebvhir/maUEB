---
title: "Example of workflow for microarray analysis using maUEB package"
author: "Mireia Ferrer, Ricardo Gonzalo and Alex Sanchez"
date: '`r Sys.Date()`'
output: 
    BiocStyle::html_document:
        toc_float:
            collapsed: true
            smooth_scroll: false
vignette: >
  %\VignetteIndexEntry{Example_microarray_analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE,  comment = "#>")
# knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The `maUEB` package contains functions to analyze data from microarray experiments. This vignette shows an example of use of `maUEB` package to run a complete microarray analysis. The workflow includes the following steps:

1. Initialization
    + set up project directories
    + load required packages
    + set up the global parameters of the study
    + prepare the targets dataframe
2. Data for the analysis
    + Sample data: load the targets dataframe
    + Microarray data: read or load raw data
3. Data preprocessing and Quality Control
    + Quality control of raw data
    + Background substraction, normalization and summarization
    + Quality Control of normalized data and sources of variability
    + Filtering
4. Differential expression analysis
    + Top tables
    + Volcano plots
5. Multiple comparisons analysis
    + Venn diagrams
    + Expression profiles
6. Analysis of Biological Significance
    + GO analysis
    + Reactome analysis

# Example data

The example is based on a study deposited in the [Gene Expression Omnibus](https://www.ncbi.nlm.nih.gov/geo/) (GEO) and published in ref. The study is based on 12 samples hybridized in Clariom S Mouse Arrays from _Thermofisher_. The experiment condition considered in this study is:

* Treatment:
    + 4 samples from untreated mice (*CTL*)
    + 4 samples from mice treated with PD1 (*PD1*)
    + 4 samples from mice treated with CMP (*CMP*)

For illustration purposes, an imaginary Batch factor will be added to the sample data.

The following group of comparisons will be performed to determine the effects of each treatment on gene expression:

* Effect of Treatment:
    + PD1vsCTL = PD1 - CTL
    + CMPvsCTL = CMP - CTL
    + PD1vsCMP = PD1 - CMP

# Running the analysis

## Initialization

### Load packages

```{r}
if (!require(maUEB)){
    require(devtools)
    install_github("uebvhir/maUEB", build_vignettes = TRUE)
}
```

### Set directories

```{r}
# Set working directory (it paths to vignette directory)
workingDir  <- getwd()
# Parameters directory
paramDir <- file.path(workingDir, "parameters")
```

### Load global parameters

```{r}
source(file.path(paramDir, "global_parameters.par"))
```

For this example study, global parameters were set as follows:

```{r}
(global_parameters <- read.table(file.path(paramDir, "global_parameters.par"), header = FALSE, sep=";", as.is=TRUE))
```

### Set directories from parameters

```{r}
dataDir <- file.path(workingDir, dataDirN)
celDir <-  file.path(workingDir, celDirN)
resultsDir <- file.path(workingDir, resultsDirN)
```

### Targets preparation {#buildTargets}

The `build_targets()` function can be used to build a targets template dataframe that will then be manually filled. The targets template built will contain the filename of the arrays in rows and the variables of interest in columns.  First column (`FileName`) contains the names of the cel files contained in the celfiles directory specified in parameters. The remaining columns correspond to the descriptors specified in global parameters, among which there will be the following: `Group`,  `ShortName`, and `Colors`. Other variables may be `Batch`, `PatientID`, or other variables of interest that may be added by the user. The targets template built is saved as a semicolon-separated file named _targets.RSRCHR.STUDY.template.csv_, where `RSRCHR` refers to client acronym and `STUDY` refers to the study UEB id.

An example of the targets generated for this study is shown below:

```{r}
build_targets(inputDir=celDir, outputDir=dataDir, client=client, ID=ID, descriptors=descriptors)
```

```{r}
(targets_template <- read.table(file.path(dataDir, "targets.RSRCHR.STUDY.template.csv"), header = TRUE, sep = ";", as.is=TRUE))
```

Then, the information for each descriptor needs to be filled manually in excel/libreoffice and saved as csv file _targets.RSRCHR.STUDY.csv_ using `;` as field separator.

## Block 01-Load-QC-Norm-Filt

### Load the parameters for this block

```{r}
#Parameters
source(file.path(paramDir, "01-Load-QC-Norm-Filt.par"))
#Execution parameters
source(file.path(paramDir, "01-Load-QC-Norm-Filt_analysistodo.par"))
```

For this example study, parameters were set as follows:

```{r}
(loadQCNormfilt_parameters <- read.table(file.path(paramDir, "01-Load-QC-Norm-Filt.par"), header = FALSE, sep=";", as.is=TRUE))
```

The execution parameters were set as follows:

```{r}
(loadQCNormfilt_todoparameters <- read.table(file.path(paramDir, "01-Load-QC-Norm-Filt_analysistodo.par"), header = FALSE, sep=";", as.is=TRUE))
```

### Load the targets file

Function `read_targets` reads the targets file specified in `targetsFN` (here _targets.RSRCHR.STUDY.csv_) that was generated in section \@ref(buildTargets). The cel file names contained in column `FileName` are set as rownames and factor variables specified by parameter `targets.fact` are converted to factors.

```{r}
(targets <- read_targets(inputDir=dataDir, targetsFN=targetsFN, targets.fact=targets.fact))
```

The targets contains `r nrow(targets)` rows and `r ncol(targets)` columns. A summary of the variables is shown below:

```{r}
summary(targets)
```

### Load raw data and create ExpressionSet object

Raw data can be read from the cel files or directly loaded from an existing Rda object ("rawData.Rda"). Function `read_celfiles()` reads the cel files listed in targets rownames (and in the same order) that are contained in the `celDir` directory and returns an object of class `ExpressionSet`.

```{r echo=FALSE, message=FALSE}
if (readcelFiles){
    eset_raw <- read_celfiles(inputDir=celDir, targets=targets)
    } else {if (loadRawData) {load(file.path(dataDir, "rawData.Rda"))}}
```

The `ExpressionSet` object contains the following fields:

* `assayData`: A matrix of expression values, where the rows represent probe sets (_features_) and columns represent samples. Row and column names must be unique, and consistent with row names of featureData and phenoData, respectively. The assay data can be retrieved with `exprs()`. Note that it can be subsetted though not reassigned. To reassign a new expression matrix one must create a new ExpressionSet.

* `phenoData`: An AnnotatedDataFrame containing information about each sample as defined in the targets file. The number of rows in phenoData must match the number of columns in assayData. Row names of phenoData must match column names of the matrix in assayData. The phenoData can be retrieved or assigned with `pData()`.

* `annotation`: A character describing the platform on which the samples were assayed. This is often the name of a Bioconductor chip annotation package. Can be retrieved or assigned with `annotation()`. For ClariomS/D it is automatically filled by the platform chip annotation.

```{r}
eset_raw
```

In this example study, the expression matrix of raw data contains `r nrow(exprs(eset_raw))` rows (features) and `r ncol(exprs(eset_raw))` columns (samples).

From now on, we will work with the `ExpressionSet` object `eset_raw`. This means that the phenotypic, annotation and expression data will be accessed from that object.

### Quality control (QC) of raw data

Performs different exploratory analyses (Boxplot, PCA, Heatmap of sample distances and hierarchical clustering) to inspect graphically the quality of samples from raw data. As well, a report of QC is generated using the array quality metrics package.

#### Boxplot of raw data

Creates a boxplot of log2-transformed intensity values from raw data and saves it as pdf into the results directory.

```{r}
if (boxplotRawData){
   qc_boxplot(data=eset_raw, group="Group", group.color="Colors", samplenames="ShortName", outputDir=resultsDir, label="RawData")
}
```

#### PCA of raw data

Performs a principal component analysis of raw data and creates different PCA plots with samples colored for each factor variable specified in 'pcaRawData.fact' from parameters. The PCA plot can be performed in 2 and/or 3 dimensions (representing the first 2 or 3 principal components) by setting the `dim` parameter. The loads (percentage of variance) cumulated for each of the principal components are returned.

```{r}
if (pcaRawData){
    loadsPCAraw <- qc_pca1(data=exprs(eset_raw), scale=pcaRawData.scale, pca2D_factors=pcaRawData.fact, targets=targets, col.group="Colors", colorlist=colorlist, names=targets$ShortName, outputDir=resultsDir, label="RawData")
}
```
```{r}
#si el volem en 3 dimensions:
if (pcaRawData){
    loadsPCAraw <- qc_pca1(data=exprs(eset_raw), scale=pcaRawData.scale, dim=3, pca3D_factors="Group", targets=targets, col.group="Colors", colorlist=colorlist, names=targets$ShortName, outputDir=resultsDir, label="RawData")
}
```

#### Heatmap of sample distances and hierarchical clustering of raw data

```{r}
if (heatmapRawData){
    qc_hc(data=exprs(eset_raw), hclust.method=hclustRawData.method, names=targets$ShortName, cexRow = 0.6, cexCol = 0.6, rect=TRUE, numclusters=2, outputDir=resultsDir, label="RawData")
}
```

#### ArrayQualityMetrics of raw data

```{r eval=FALSE}
#Note: Set 'intgroup' according to factors to be colored in heatmap. Other plots will be colored according to only the first factor
#required for Affymetrix QC
if (arrayQMRawData) {
    require(arrayQualityMetrics) 
    arrayQualityMetrics(eset_raw, outdir = file.path(resultsDir, "QCDir.Raw"), force=TRUE, intgroup=targets.fact)
}
```

### QC of raw data in one step

All the QC plots performed above can be performed in one step with function `qc_all`:

```{r}
qc_all(data=eset_raw, group="Group", group.color="Colors", samplenames="ShortName", factors=pcaRawData.fact, pca_scale=pcaRawData.scale, colorlist=colorlist, hc.method=hclustRawData.method, label="RawData", outputDir=resultsDir, summaryFN=resultsSummFN, doboxplot=TRUE, dopca=TRUE, dopvca=FALSE, dohc=TRUE, doarrayQMreport=FALSE)
```

### Normalization

Data can be normalized using `normalization()` function or directly loaded from an Rda object (`normData.Rda`) previously generated. The `normalization()` function normalizes raw data using one of the available methods (currently: rma method from oligo package). The RMA method allows background subtraction, quantile normalization and summarization (via median-polish) (ref). It returns a `FeatureSet` of normalized data and saves the normalized expression values in a datasheet (csv and/or xls file format) in the results folder. 

```{r}
if (loadNormData) {
    load(file.path(dataDir, "normData.Rda"))
} else if (normalize) {
    eset_norm <- normalization(data=eset_raw, norm.method="rma", annotPkg=annotPackage, outputFN="Normalized.All", outputDir=resultsDir)
}
```

### Save annotations of summarized probes

Constructs an aafTable object given a set of probe ids using `aafTableAnn` function from `annaffy` package. The dataframe with annotations is returned as an `aafTable` object and it also saves the annotation for all summarized probes as csv and html files. Note: in Exon studies, where probes are summarized at the probeset level but not transcript level, the probe annotations cannot be recovered using this function.

```{r eval=FALSE}
#no se pq dona error, nomes passa quan s'executa com a funcio sense haver previament carregat els paquets (?)
if (save_annot_all){normData_annot <- save_annotations(data=rownames(eset_norm), annotPkg=annotPackage, outputFN="Annotations.AllGenes", saveHTML=TRUE, title="Annotations for all genes", outputDir=resultsDir)}
```

### Quality control of normalized data

Here, the same functions used for quality control of raw data can be used to assess the quality of data after normalization. As an extra analysis, a PVCA (principal variance component analysis) can also be performed to further assess the source of batch effects in normalize data.

#### Boxplot of normalized data

Creates a boxplot of the normalized data (already in log2 scale) and saves it as pdf into the results directory.

```{r}
if (boxplotNormData){
   qc_boxplot(data=eset_norm, group="Group", col="Colors", names="ShortName", outputDir=resultsDir, label="NormData")
}
```

#### PCA of normalized data

Performs a principal component analysis of normalized data and creates different PCA plots with samples colored for each factor variable specified in 'pcaNormData.fact' from parameters. The loads (percentage of variance) cumulated for each of the principal components are returned.

```{r}
if (pcaNormData){
    loadsPCAnorm <- qc_pca1(data=exprs(eset_norm), scale=pcaNormData.scale, pca2D_factors=pcaNormData.fact, targets=targets, col.group="Colors", colorlist=colorlist, names=targets$ShortName, outputDir=resultsDir, label="NormData")
}
```

If there are batch effects, the PCA can be repeated removing the batch effects using the `removeBatchEffect` function from `limma` package. Here this step is performed only for illustration purposes, since the `Batch` variable is artificial. We use the same function as for the PCA but specify `batchRemove=TRUE` and the name of `Batch` variable in `batchFactors` parameter.

```{r}
if (pcaNormData.corrbatch){
    loadsPCAnorm.corrbatch <- qc_pca1(exprs(eset_norm), scale=pcaNormData.scale, pca2D_factors=pcaNormData.fact, targets=targets, col.group="Colors", colorlist=colorlist, names=targets$ShortName, outputDir=resultsDir, label="NormData", batchRemove=TRUE, batchFactors="Batch", size = 1.5, glineas = 0.25)
}
```

#### Heatmap of sample distances and hierarchical clustering of normalized data

```{r}
if (heatmapNormData){
    qc_hc(data=exprs(eset_norm), hclust.method=hclustNormData.method, names=targets$ShortName, cexRow = 0.6, cexCol = 0.6, rect=TRUE, numclusters=2, outputDir=resultsDir, label="NormData")
}
```

#### ArrayQualityMetrics of normalized data

```{r eval=FALSE}
#Note: Set 'intgroup' according to factors to be colored in heatmap. Other plots will be colored according to only the first factor
require(arrayQualityMetrics) #required for Affymetrix QC
if (arrayQMNormData) arrayQualityMetrics(eset_norm, outdir = file.path(resultsDir, "QCDir.Norm"), force=TRUE, intgroup=targets.fact)
```

#### PVCA of normalized data 

The PVCA approach can be used as a screening tool to determine which sources of variability (biological, technical or other) are most prominent in a given microarray data set.

```{r message=FALSE}
if (pvcaNormData){
    qc_pvca(data=eset_norm, factors=pvcaNormData.fact, targets=targets.pvcaFN, pct_threshold=pct_threshold, label=".NormData", outputDir=resultsDir, summaryFN=resultsSummFN)
}
```

### QC of normalized data in one step

All the QC plots performed above can be performed in one step with function `qc_all`:

```{r}
qc_all(data=eset_norm, group="Group", group.color="Colors", samplenames="ShortName", factors=pcaNormData.fact, pca_scale=pcaNormData.scale, colorlist=colorlist, hc.method=hclustNormData.method, label="NormData", outputDir=resultsDir, summaryFN=resultsSummFN, doboxplot=TRUE, dopca=TRUE, dopvca=TRUE, dohc=TRUE, doarrayQMreport=FALSE)
```

### Sample exclusion

The Quality Control may reveal some outlier samples that should be removed before proceeding with the differential expression analysis. Here, sample `CMP.2` appears as a putative outlier both in the hierarchical clustering and PCA analysis. Therefore, this sample will be discarded from the analysis. 

To remove samples, the whole ExpressionSet object can be subsetted as follows:

```{r}
samplestoremove <- "CMP.2"
eset_raw.f <- eset_raw[,-which(colnames(eset_raw)%in%samplestoremove)]
dim(eset_raw)
dim(eset_raw.f)
```
Note that the phenoData contained in that object has also been subsetted:

```{r}
pData(eset_raw.f)
targets.f <- pData(eset_raw.f)
```

After sample removal, the whole QC and normalization process should be repeated without those samples.

Hence, data is normalized with the new dataset (here we don't change the `outputFN` parameter so that files _Normalized.All.xls_ and _Normalized.All.csv_ are overwritten):

```{r}
eset_norm.f <- normalization(data=eset_raw.f, norm.method="rma", annotPkg=annotPackage, outputFN="Normalized.All", outputDir=resultsDir)
```

The QC is performed again with the normalized data after sample exclusion. We will indicate that the plots correspond to the dataset after sample exclusion by adding `.f` in `label` parameter:

```{r}
qc_all(data=eset_norm.f, group="Group", group.color="Colors", samplenames="ShortName", factors=pcaNormData.fact, pca_scale=pcaNormData.scale, colorlist=colorlist, hc.method=hclustNormData.method, label="NormData.f", outputDir=resultsDir, summaryFN=resultsSummFN, doboxplot=TRUE, dopca=TRUE, dopvca=FALSE, dohc=TRUE, doarrayQMreport=FALSE)
```

If there were batch effects, we should also repeat the PCA removing batch effects with the new dataset:

```{r}
loadsPCAnorm.f.corrbatch <- qc_pca1(exprs(eset_norm.f), scale=pcaNormData.scale, pca2D_factors=pcaNormData.fact, targets=targets.f, col.group="Colors", colorlist=colorlist, names=targets.f$ShortName, outputDir=resultsDir, label="NormData.f", batchRemove=TRUE, batchFactors="Batch", size = 1.5, glineas = 0.25)
```

### Filtering


#### SD plot
#### Filter normalized data
#### Save annotations of filtered data

### Save data from this block (normData.Rda object)

## Differential Expression Analysis
## Multiple Comparisons
## Analysis of Biological Significance

