---
title: "Example of workflow for microarray analysis using maUEB package"
author: "Mireia Ferrer, Ricardo Gonzalo and Alex Sanchez"
date: '`r Sys.Date()`'
output: 
    BiocStyle::html_document:
        toc_float:
            collapsed: true
            smooth_scroll: false
vignette: >
  %\VignetteIndexEntry{Example_microarray_analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE,  comment = "#>")
# knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The `maUEB` package contains functions to analyze data from microarray experiments. This vignette shows an example of use of `maUEB` package to run a complete microarray analysis. The workflow includes the following steps:

1. Initialization
    + set up project directories
    + load required packages
    + set up the global parameters of the study
    + prepare the targets dataframe
2. Data for the analysis
    + Sample data: load the targets dataframe
    + Microarray data: read or load raw data
3. Data preprocessing and Quality Control
    + Quality control of raw data
    + Background substraction, normalization and summarization
    + Quality Control of normalized data and sources of variability
    + Filtering
4. Differential expression analysis
    + Top tables
    + Volcano plots
5. Multiple comparisons analysis
    + Venn diagrams
    + Expression profiles
6. Analysis of Biological Significance
    + GO analysis
    + Reactome analysis

# Example data

The example is based on a study deposited in the [Gene Expression Omnibus](https://www.ncbi.nlm.nih.gov/geo/) (GEO) and published in ref. The study is based on 12 samples hybridized in Clariom S Mouse Arrays from _Thermofisher_. The experiment condition considered in this study is:

* Treatment:
    + 4 samples from untreated mice (*CTL*)
    + 4 samples from mice treated with PD1 (*PD1*)
    + 4 samples from mice treated with CMP (*CMP*)

For illustration purposes, an imaginary Batch factor will be added to the sample data.

The following group of comparisons will be performed to determine the effects of each treatment on gene expression:

* Effect of Treatment:
    + PD1vsCTL = PD1 - CTL
    + CMPvsCTL = CMP - CTL
    + PD1vsCMP = PD1 - CMP

# Running the analysis

## Initialization

### Load packages

```{r}
if (!require(maUEB)){
    require(devtools)
    install_github("uebvhir/maUEB", build_vignettes = TRUE)
}
```

### Set directories

```{r}
# Set working directory (it paths to vignette directory)
workingDir  <- getwd()
# Parameters directory
paramDir <- file.path(workingDir, "parameters")
```

### Load global parameters

```{r}
source(file.path(paramDir, "global_parameters.par"))
```

For this example study, global parameters were set as follows:

```{r}
(global_parameters <- read.table(file.path(paramDir, "global_parameters.par"), header = FALSE, sep=";", as.is=TRUE))
```

### Set directories from parameters

```{r}
dataDir <- file.path(workingDir, dataDirN)
celDir <-  file.path(workingDir, celDirN)
resultsDir <- file.path(workingDir, resultsDirN)
```

### Targets preparation {#buildTargets}

The `build_targets()` function can be used to build a targets template dataframe that will then be manually filled. The targets template built will contain the filename of the arrays in rows and the variables of interest in columns.  First column (`FileName`) contains the names of the cel files contained in the celfiles directory specified in parameters. The remaining columns correspond to the descriptors specified in global parameters, among which there will be the following: `Group`,  `ShortName`, and `Colors`. Other variables may be `Batch`, `PatientID`, or other variables of interest that may be added by the user. The targets template built is saved as a semicolon-separated file named _targets.RSRCHR.STUDY.template.csv_, where `RSRCHR` refers to client acronym and `STUDY` refers to the study UEB id.

An example of the targets generated for this study is shown below:

```{r}
build_targets(inputDir=celDir, outputDir=dataDir, client=client, ID=ID, descriptors=descriptors)
```

```{r}
(targets_template <- read.table(file.path(dataDir, "targets.RSRCHR.STUDY.template.csv"), header = TRUE, sep = ";", as.is=TRUE))
```

Then, the information for each descriptor needs to be filled manually in excel/libreoffice and saved as csv file _targets.RSRCHR.STUDY.csv_ using `;` as field separator.

## Block 01-Load-QC-Norm-Filt

### Load the parameters for this block

```{r}
#Parameters
source(file.path(paramDir, "01-Load-QC-Norm-Filt.par"))
#Execution parameters
source(file.path(paramDir, "01-Load-QC-Norm-Filt_analysistodo.par"))
```

For this example study, parameters were set as follows:

```{r}
(loadQCNormfilt_parameters <- read.table(file.path(paramDir, "01-Load-QC-Norm-Filt.par"), header = FALSE, sep=";", as.is=TRUE))
```

The execution parameters were set as follows:

```{r}
(loadQCNormfilt_todoparameters <- read.table(file.path(paramDir, "01-Load-QC-Norm-Filt_analysistodo.par"), header = FALSE, sep=";", as.is=TRUE))
```

### Load the targets file

Function `read_targets` reads the targets file specified in `targetsFN` (here _targets.RSRCHR.STUDY.csv_) that was generated in section \@ref(buildTargets). The cel file names contained in column `FileName` are set as rownames and factor variables specified by parameter `targets.fact` are converted to factors.

```{r}
(targets <- read_targets(inputDir=dataDir, targetsFN=targetsFN, targets.fact=targets.fact))
```

The targets contains `r nrow(targets)` rows and `r ncol(targets)` columns. A summary of the variables is shown below:

```{r}
summary(targets)
```

### Load raw data

Raw data can be read from the cel files or directly loaded from an existing Rda object ("rawData.Rda"). Function `read_celfiles()` reads the cel files listed in targets rownames (and in the same order) that are contained in the `celDir` directory and returns an object of class `ExpressionSet`.

```{r echo=FALSE, message=FALSE}
if (readcelFiles){
    rawData <- read_celfiles(inputDir=celDir, targets)
    } else {if (loadRawData) {load(file.path(dataDir, "rawData.Rda"))}}
```

The `ExpressionSet` of rawData contains the following fields:

* `assayData`: A matrix of expression values, where the rows represent probe sets (_features_) and columns represent samples. Row and column names must be unique, and consistent with row names of featureData and phenoData, respectively. The assay data can be retrieved with `exprs()`.

* `phenoData`: An AnnotatedDataFrame containing information about each sample as defined in the targets file. The number of rows in phenoData must match the number of columns in assayData. Row names of phenoData must match column names of the matrix in assayData. The phenoData can be retrieved or assigned with `pData()`.

* `annotation`: A character describing the platform on which the samples were assayed. This is often the name of a Bioconductor chip annotation package. Can be retrieved or assigned with `annotation()`.

```{r}
rawData
```

In this example study, the expression matrix of raw data contains `r nrow(exprs(rawData))` rows (features) and `r ncol(exprs(rawData))` columns (samples).

### Quality control (QC) of raw data

Performs different exploratory analyses (Boxplot, PCA, Heatmap of sample distances and hierarchical clustering) to inspect graphically the quality of samples from raw data. As well, a report of QC is generated using the array quality metrics package.

#### Boxplot of raw data

Creates a boxplot of log2-transformed intensity values from raw data and saves it as pdf into the results directory.

```{r}
if (boxplotRawData){
   qc_boxplot(data=rawData, group=targets$Group, col=targets$Colors, names=targets$ShortName, outputDir=resultsDir, label="RawData")
}
```

#### PCA of raw data

Performs a principal component analysis of raw data and creates different PCA plots with samples colored for each factor variable specified in 'pcaRawData.fact' from parameters. The loads (percentage of variance) cumulated for each of the principal components are returned.

```{r}
if (pcaRawData){
    loadsPCAraw <- qc_pca(data=exprs(rawData), scale=pcaRawData.scale, factors=pcaRawData.fact, targets=targets, col.group="Colors", colorlist=colorlist, names=targets$ShortName, outputDir=resultsDir, label="RawData")
}
```

#### Heatmap of sample distances and hierarchical clustering of raw data

```{r}
if (heatmapRawData){
    qc_hc(data=exprs(rawData), hclust.method=hclustRawData.method, names=targets$ShortName, cexRow = 0.6, cexCol = 0.6, rect=TRUE, numclusters=2, outputDir=resultsDir, label="RawData")
}
```

#### ArrayQualityMetrics of raw data

```{r eval=FALSE}
#Note: Set 'intgroup' according to factors to be colored in heatmap. Other plots will be colored according to only the first factor
require(arrayQualityMetrics) #required for Affymetrix QC
if (arrayQMRawData) arrayQualityMetrics(rawData, outdir = file.path(resultsDir, "QCDir.Raw"), force=TRUE, intgroup=targets.fact)
```

### Normalization

Data can be normalized using `normalization()` function or directly loaded from an Rda object (`normData.Rda`) previously generated. The `normalization()` function normalizes raw data using one of the available methods (currently: rma method from oligo package). The RMA method allows background subtraction, quantile normalization and summarization (via median-polish) (ref). It returns a `FeatureSet` of normalized data and saves the normalized expression values in a datasheet (csv and/or xls file format) in the results folder. 

```{r}
if (loadNormData) {
    load(file.path(dataDir, "normData.Rda"))
} else if (normalize) {
    eset_norm <- normalization(data=rawData, norm.method="rma", annotPkg=annotPackage, outputFN="Normalized.All", outputDir=resultsDir)
}
```

### Save annotations of summarized probes

Constructs an aafTable object given a set of probe ids using `aafTableAnn` function from `annaffy` package. The dataframe with annotations is returned as an `aafTable` object and it also saves the annotation for all summarized probes as csv and html files. Note: in Exon studies, where probes are summarized at the probeset level but not transcript level, the probe annotations cannot be recovered using this function.

```{r eval=FALSE}
if (save_annot_all){normData_annot <- save_annotations(data=rownames(eset_norm), annotPkg=annotPackage, outputFN="Annotations.AllGenes", saveHTML=TRUE, title="Annotations for all genes", outputDir=resultsDir)}
```

### Quality control of normalized data

Performs different exploratory analyses (Boxplot, PCA, Heatmap of sample distances and hierarchical clustering) to inspect graphically the quality of samples from raw data. As well, a report of QC is generated using the array quality metrics package.

#### Boxplot of normalized data

Creates a boxplot of the normalized data (already in log2 scale) and saves it as pdf into the results directory.

```{r}
if (boxplotNormData){
   qc_boxplot(data=eset_norm, group=targets$Group, col=targets$Colors, names=targets$ShortName, outputDir=resultsDir, label="NormData")
}
```

#### PCA of normalized data

Performs a principal component analysis of normalized data and creates different PCA plots with samples colored for each factor variable specified in 'pcaNormData.fact' from parameters. The loads (percentage of variance) cumulated for each of the principal components are returned.

```{r}
if (pcaNormData){
    loadsPCAnorm <- qc_pca(data=exprs(eset_norm), scale=pcaNormData.scale, factors=pcaNormData.fact, targets=targets, col.group="Colors", colorlist=colorlist, names=targets$ShortName, outputDir=resultsDir, label="NormData")
}
```

If there are batch effects, the PCA can be repeated removing the batch effects using the `removeBatchEffect` function from `limma` package. Here this step is performed only for illustration purposes:

```{r}
if (pcaNormData.corrbatch){
    require(limma)
    #apply correction for batch effect to normalized data
    batch <- as.factor(targets[,batchcolName])
    normData.corrbatch <- removeBatchEffect(exprs(eset_norm), batch=batch) #function from limma package
    loadsPCAnorm.corrbatch <- qc_pca(data=normData.corrbatch, scale=pcaNormData.scale, factors=pcaNormData.fact, targets=targets, col.group="Colors", colorlist=colorlist, names=targets$ShortName, outputDir=resultsDir, label="NormData-corrbatch")
}
```

#### Heatmap of sample distances and hierarchical clustering of normalized data

```{r}
if (heatmapNormData){
    qc_hc(data=exprs(eset_norm), hclust.method=hclustNormData.method, names=targets$ShortName, cexRow = 0.6, cexCol = 0.6, rect=TRUE, numclusters=2, outputDir=resultsDir, label="NormData")
}
```

#### ArrayQualityMetrics of normalized data

```{r eval=FALSE}
#Note: Set 'intgroup' according to factors to be colored in heatmap. Other plots will be colored according to only the first factor
require(arrayQualityMetrics) #required for Affymetrix QC
if (arrayQMNormData) arrayQualityMetrics(eset_norm, outdir = file.path(resultsDir, "QCDir.Norm"), force=TRUE, intgroup=targets.fact)
```

#### PVCA of normalized data 

The PVCA approach can be used as a screening tool to determine which sources of variability (biological, technical or other) are most prominent in a given microarray data set.

```{r message=FALSE}
if (pvcaNormData){
    qc_pvca(data=eset_norm, factors=pvcaNormData.fact, targets=targets.pvcaFN, pct_threshold=pct_threshold, label=".NormData", outputDir=resultsDir, summaryFN=resultsSummFN)
}
```

### Filtering

#### SD plot
#### Filter normalized data
#### Save annotations of filtered data

### Save data from this block (normData.Rda object)

## Differential Expression Analysis
## Multiple Comparisons
## Analysis of Biological Significance

